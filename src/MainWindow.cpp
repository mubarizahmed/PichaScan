#include "MainWindow.h"
#include "ui_MainWindow.h"

#include "CroppedView.h"
#include "ImageEditorView.h"
#include "QuadrilateralItem.h"
#include "ScanProcessor.h"
#include "ScannerInterface.h"

#include <QDebug>
#include <QFileDialog>
#include <QGraphicsRectItem>
#include <QListWidget>
#include <QMessageBox>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), ui(new Ui::MainWindow) {

    scanner = nullptr;

    ui->setupUi(this);

    // Replace the autogenerated QGraphicsView with your custom class
    scanScene = new QGraphicsScene(this);
    // set white bg

    scanView = new ImageEditorView(this);
    scanView->setBackgroundBrush(Qt::white);
    scanView->setScene(scanScene);
    scanView->positionButtons();

    // Set the geometry and properties of the new scanView
    scanView->setGeometry(ui->scanView->geometry());
    scanView->setObjectName(ui->scanView->objectName());
    scanView->setSizePolicy(ui->scanView->sizePolicy());

    // Add scanView to the layout or as needed
    auto parentLayout = ui->scanView->parentWidget()->layout();
    if (parentLayout) {
        parentLayout->replaceWidget(ui->scanView, scanView);
    }

    // Delete the old QGraphicsView instance
    delete ui->scanView;
    ui->scanView = scanView;

    // Suppose you have a QPushButton named scanButton in your .ui
    connect(ui->btnScan, &QPushButton::clicked,
            this, &MainWindow::onScanButtonClicked);

    connect(ui->btnFindScanners, &QPushButton::clicked, this, &MainWindow::onFindScannerButtonClicked);

    connect(ui->comboScanners, SIGNAL(currentTextChanged(QString)), this, SLOT(onScannerSelectionChanged(QString)));

    connect(scanView, &ImageEditorView::quadrilateralsChanged, this, &MainWindow::updateThumbnailsList);

    onFindScannerButtonClicked();

    scanView->positionButtons();
    scanView->updateGeometry();

    croppedView = new CroppedView(this);
    // croppedView->setGeometry(ui->listThumbnails->geometry());
    croppedView->setObjectName(ui->listThumbnails->objectName());
    croppedView->setSizePolicy(ui->listThumbnails->sizePolicy());

    // Add croppedView to the layout or as needed
    auto croppedParentLayout = ui->listThumbnails->parentWidget()->layout();
    if (croppedParentLayout) {
        croppedParentLayout->replaceWidget(ui->listThumbnails, croppedView);
    }

    // Delete the old QListView instance
    delete ui->listThumbnails;
    ui->listThumbnails = croppedView;
}

MainWindow::~MainWindow() {
    delete ui;
}

void MainWindow::onScanButtonClicked() {

    if (!scanner) {
        QMessageBox::warning(this, "Error", "No suitable scanner backend found!");
        return;
    }

    // Perform the scan (returns a large image that might contain multiple photos)
    cv::Mat scannedImage = scanner->scanImage();
    if (scannedImage.empty()) {
        QMessageBox::warning(this, "Error", "Failed to scan or no image returned.");
        return;
    }

    scanImage = scannedImage;

    // Use the ScanProcessor to detect & crop
    ScanProcessor processor;
    ScanResult scanResult = processor.detectAndCropPhotos(scannedImage);

    // Display the scanned image in the graphics view
    MainWindow::displayMatInGraphicsView(scanResult.annotated, scanView, scanScene);

    // Add rectangles to the scanScene
    std::vector<std::vector<cv::Point>> quads;
    for (const auto &region : scanResult.regions) {
        auto *quad = new QuadrilateralItem(region.corners, scanScene, scanScene);
        quads.push_back(region.corners);
        connect(quad, &QuadrilateralItem::positionChanged, scanView, &ImageEditorView::updateQuads);
    }

    // Update the list of thumbnails
    updateThumbnailsList(quads);
}

void MainWindow::onFindScannerButtonClicked() {
    if (!scanner) {
        scanner = ScannerInterface::createScanner();
    }

    if (!scanner) {
        QMessageBox::warning(this, "Error", "No suitable scanner backend found!");
        return;
    }

    // std::vector<std::wstring> scanners = scanner->getAvailableScanners();
    std::vector<std::wstring> scanners = scanner->getAvailableScanners();

    if (scanners.empty()) {
        QMessageBox::information(this, "Info", "No scanners found.");
        return;
    }

    // add to combo box
    QStringList scannerList;
    for (const auto &scanner : scanners) {
        scannerList += QString::fromStdWString(scanner);
    }

    ui->comboScanners->addItems(scannerList);
}

void MainWindow::onScannerSelectionChanged(QString scannerName) {
    if (!scanner) {
        QMessageBox::warning(this, "Error", "No suitable scanner backend found!");
        return;
    }

    std::wstring scannerNameW = scannerName.toStdWString();

    std::cout << "Selected scanner: " << scannerName.toStdString() << std::endl;

    scanner->setPreferredScanner(scannerNameW);
}

void MainWindow::updateThumbnailsList(std::vector<std::vector<cv::Point>> quads) {
    qDebug() << "Updating thumbnails list with " << quads.size() << " quadrilaterals.";
    // Clear the existing listview
    croppedView->model()->removeRows(0, croppedView->model()->rowCount());

    // Use the ScanProcessor to crop the images
    ScanProcessor processor;
    croppedImages = processor.cropImages(scanImage, quads);

    // Display the cropped images in the list
    for (const auto &cropped : croppedImages) {

        // Convert cv::Mat to QImage
        QImage qImage = matToQImage(cropped);

        // Convert QImage to QPixmap
        QPixmap pixmap = QPixmap::fromImage(qImage);

        croppedView->addImageItem(pixmap);
    }
    croppedView->manualResize();
}

void MainWindow::displayMatInGraphicsView(const cv::Mat &mat, ImageEditorView *graphicsView, QGraphicsScene *scene) {
    qDebug() << "Mat empty:" << mat.empty();
    qDebug() << "Mat type:" << mat.type();
    qDebug() << "Mat rows:" << mat.rows << ", cols:" << mat.cols;
    // Convert cv::Mat to QImage
    // Handle supported formats
    QImage qImage = matToQImage(mat);

    // Convert QImage to QPixmap
    QPixmap pixmap = QPixmap::fromImage(qImage);

    // clear scene
    scene->clear();

    scene->addPixmap(pixmap);

    // Set the scene to the graphics view
    graphicsView->setScene(scene);

    // Optional: Adjust the view to fit the image
    graphicsView->fitInView(scene->itemsBoundingRect(), Qt::KeepAspectRatio);
    graphicsView->positionButtons();
}

QImage MainWindow::matToQImage(const cv::Mat &mat) {
    // Check if the matrix is valid
    if (mat.empty()) {
        qDebug() << "Empty matrix provided to matToQImage.";
        return QImage();
    }

    switch (mat.type()) {
    case CV_8UC1: { // Grayscale
        return QImage(mat.data, mat.cols, mat.rows, static_cast<int>(mat.step), QImage::Format_Grayscale8).copy();
    }
    case CV_8UC3: { // BGR to RGB
        cv::Mat rgbMat;
        cv::cvtColor(mat, rgbMat, cv::COLOR_BGR2RGB);
        return QImage(rgbMat.data, rgbMat.cols, rgbMat.rows, static_cast<int>(rgbMat.step), QImage::Format_RGB888).copy();
    }
    case CV_8UC4: { // BGRA to RGBA
        return QImage(mat.data, mat.cols, mat.rows, static_cast<int>(mat.step), QImage::Format_RGBA8888).copy();
    }
    case CV_16UC1: { // 16-bit Grayscale
        // Normalize to 8-bit range [0, 255]
        cv::Mat mat8;
        mat.convertTo(mat8, CV_8UC1, 255.0 / 65535.0); // Scale 16-bit to 8-bit
        return QImage(mat8.data, mat8.cols, mat8.rows, static_cast<int>(mat8.step), QImage::Format_Grayscale8).copy();
    }
    case CV_16UC3: { // 16-bit BGR
        cv::Mat mat8;
        mat.convertTo(mat8, CV_8UC3, 255.0 / 65535.0); // Scale 16-bit to 8-bit
        cv::Mat rgbMat;
        cv::cvtColor(mat8, rgbMat, cv::COLOR_BGR2RGB);
        return QImage(rgbMat.data, rgbMat.cols, rgbMat.rows, static_cast<int>(rgbMat.step), QImage::Format_RGB888).copy();
    }
    default:
        qDebug() << "Unsupported matrix type for QImage conversion: " << mat.type();
        throw std::runtime_error("Unsupported cv::Mat type for QImage conversion.");
    }
}