#include "MainWindow.h"
#include "ui_MainWindow.h"

#include "CroppedView.h"
#include "ImageEditorView.h"
#include "Project.h"
#include "QuadrilateralItem.h"
#include "ScanProcessor.h"
#include "ScannerInterface.h"

#include "ImageSaver.h"
#include <QDebug>
#include <QFileDialog>
#include <QGraphicsRectItem>
#include <QListWidget>
#include <QMessageBox>
#include <QtQml>

#include "C:\Qt\6.8.1\mingw_64\include\QtQml\qqmlcontext.h"
#include "C:\Qt\6.8.1\mingw_64\include\QtQml\qqmlengine.h"
#include "C:\Qt\6.8.1\mingw_64\include\QtQuickWidgets\qquickwidget.h"
#include <QtLocation>
#include <QtQuickWidgets>

MainWindow::MainWindow(std::string path, QWidget *parent)
    : QMainWindow(parent), ui(new Ui::MainWindow) {

    projectPath = path;
    projectData = Project::loadProject(projectPath);
    scanner = nullptr;

    ui->setupUi(this);

    ui->labelProject->setText(QString::fromStdString(projectData.projectName));
    ui->projectCount->display(projectData.imagesCount);

    // Replace the autogenerated QGraphicsView with your custom class
    scanScene = new QGraphicsScene(this);
    // set white bg

    scanView = new ImageEditorView(this);
    scanView->setBackgroundBrush(Qt::white);
    scanView->setScene(scanScene);
    scanView->positionButtons();

    // Set the geometry and properties of the new scanView
    scanView->setGeometry(ui->scanView->geometry());
    scanView->setObjectName(ui->scanView->objectName());
    scanView->setSizePolicy(ui->scanView->sizePolicy());

    // Add scanView to the layout or as needed
    auto parentLayout = ui->scanView->parentWidget()->layout();
    if (parentLayout) {
        parentLayout->replaceWidget(ui->scanView, scanView);
    }

    // Delete the old QGraphicsView instance
    delete ui->scanView;
    ui->scanView = scanView;

    

    onFindScannerButtonClicked();

    // select the scanner from the combo box from projectData.scannerName
    int index = ui->comboScanners->findText(QString::fromStdString(projectData.scannerName));
    if (index != -1) {
        ui->comboScanners->setCurrentIndex(index);
    } else {
        ui->comboScanners->setCurrentIndex(0);
    }

    // set the time
    QDateTime dateTime = QDateTime::fromString(QString::fromStdString(projectData.imageDateTime), Qt::ISODate);
    ui->dateTimeEdit->setDateTime(dateTime);

    // Suppose you have a QPushButton named scanButton in your .ui
    connect(ui->btnScan, &QPushButton::clicked, this, &MainWindow::onScanButtonClicked);
    connect(ui->btnSave, &QPushButton::clicked, this, &MainWindow::onSaveButtonClicked);

    connect(ui->btnFindScanners, &QPushButton::clicked, this, &MainWindow::onFindScannerButtonClicked);

    connect(ui->comboScanners, SIGNAL(currentTextChanged(QString)), this, SLOT(onScannerSelectionChanged(QString)));

    connect(scanView, &ImageEditorView::quadrilateralsChanged, this, &MainWindow::updateThumbnailsList);
    connect(scanView, &ImageEditorView::scanRotated, [this](int angle) {
        int oldScanOrientation = projectData.scanOrientation;
        projectData.scanOrientation += angle;
        projectData.scanOrientation = (projectData.scanOrientation + 360) % 360;

        // Rotate the croppedImages
        if (std::all_of(croppedOrientation.begin(), croppedOrientation.end(),
                        [oldScanOrientation](int val) {
                            return val == -1 || val == oldScanOrientation;
                        })) {
            // Adjust elements if all are -1 or match the required condition
            for (auto &cropped : croppedOrientation) {
                cropped = projectData.scanOrientation;
            }
        }

        scanView->updateQuads();
    });

    connect(ui->dateTimeEdit, &QDateTimeEdit::dateTimeChanged, [this](const QDateTime &dateTime) {
        projectData.imageDateTime = dateTime.toString("yyyy:MM:dd HH:mm:ss").toStdString();
    });

    connect(ui->comboColor, SIGNAL(currentIndexChanged(int)), this, SLOT(onColorOptionChanged(int)));
    connect(ui->comboDPI, SIGNAL(currentIndexChanged(int)), this, SLOT(onDpiOptionChanged(int)));

    croppedView = new CroppedView(this);
    // croppedView->setGeometry(ui->listThumbnails->geometry());
    croppedView->setObjectName(ui->listThumbnails->objectName());
    croppedView->setSizePolicy(ui->listThumbnails->sizePolicy());

    // Add croppedView to the layout or as needed
    auto croppedParentLayout = ui->listThumbnails->parentWidget()->layout();
    if (croppedParentLayout) {
        croppedParentLayout->replaceWidget(ui->listThumbnails, croppedView);
    }

    connect(croppedView, &CroppedView::viewItemRotated, [this](int index, int angle) {
        int oldOrientation = croppedOrientation[index];
        croppedOrientation[index] += angle;
        croppedOrientation[index] = (croppedOrientation[index] + 360) % 360;

        // Rotate the cropped image
        if (oldOrientation == -1) {
            croppedOrientation[index] = angle;
        }

        scanView->updateQuads();
    });

    // Delete the old QListView instance
    delete ui->listThumbnails;
    ui->listThumbnails = croppedView;

    // Create a QQuickWidget for the map
    QQuickWidget *mapWidget = new QQuickWidget(this);

    // Set the QML source for the QQuickWidget
    mapWidget->setResizeMode(QQuickWidget::SizeRootObjectToView);
    mapWidget->engine()->rootContext()->setContextProperty("parentWidget", this);

    // Load QML map programmatically
    mapWidget->setSource(QUrl(QStringLiteral("qrc:/map.qml")));

    // Add the QQuickWidget to the layout or a specific widget in your UI
    mapWidget->setGeometry(ui->mapPlaceholder->geometry());
    mapWidget->setObjectName(ui->mapPlaceholder->objectName());
    mapWidget->setSizePolicy(ui->mapPlaceholder->sizePolicy());

    QLayout *mapParentLayout = ui->mapPlaceholder->parentWidget()->layout();
    if (mapParentLayout) {
        mapParentLayout->replaceWidget(ui->mapPlaceholder, mapWidget);
    }
    delete ui->mapPlaceholder;
    ui->mapPlaceholder = mapWidget;

    // Access the QML root object
    QObject *rootObject = mapWidget->rootObject();

    // loop through the children of root and qDebug their types
    for (auto *child : rootObject->children()) {
        qDebug() << child->objectName();
    }

    // Find the Map object inside the Rectangle
    QObject *mapObject = rootObject->findChild<QObject *>("pichascanmap");
    if (mapObject) {
        // Connect the signal from the Map object
        connect(mapObject, SIGNAL(mapMarkerSignal(double, double)),
                this, SLOT(handleMapMarker(double, double)));
    } else {
        qDebug() << "Map object not found in QML hierarchy!";
    }

    QObject::connect(this, &MainWindow::setInitialCoordinates,
                     rootObject, [rootObject](double latitude, double longitude) {
                         QMetaObject::invokeMethod(rootObject, "setMarkerCoordinates",
                                                   Q_ARG(QVariant, latitude), Q_ARG(QVariant, longitude));
                     });

    // Send initial coordinates to center the map and add a marker
    emit setInitialCoordinates(projectData.imageLocation.first, projectData.imageLocation.second); // Nakuru

    show();
    scanView->positionButtons();
}

MainWindow::~MainWindow() {
    delete ui;
}

void MainWindow::handleMapMarker(double latitude, double longitude) {
    qDebug() << "Marker added at:" << latitude << "," << longitude;
    // Handle marker coordinates in your application

    projectData.imageLocation = {latitude, longitude};
}

void MainWindow::onScanButtonClicked() {

    if (!scanner) {
        QMessageBox::warning(this, "Error", "No suitable scanner backend found!");
        return;
    }
    cv::Mat scannedImage;
    // Perform the scan (returns a large image that might contain multiple photos)
    try {
        scannedImage = scanner->scanImage();
    } catch (const std::exception &e) {
        QMessageBox::warning(this, "Error", "Failed to scan.");
        return;
    }

    if (scannedImage.empty()) {
        QMessageBox::warning(this, "Error", "No image returned.");
        return;
    }

    scanImage = scannedImage;

    // Use the ScanProcessor to detect & crop
    ScanProcessor processor;
    ScanResult scanResult = processor.detectAndCropPhotos(scannedImage);

    // Display the scanned image in the graphics view
    MainWindow::displayMatInGraphicsView(scanResult.annotated, scanView, scanScene);
    scanView->rotate(projectData.scanOrientation);

    // Add rectangles to the scanScene
    std::vector<std::vector<cv::Point>> quads;
    for (const auto &region : scanResult.regions) {
        scanView->addQuadrilateral(region.corners);
        quads.push_back(region.corners);
    }

    // Update the list of thumbnails
    updateThumbnailsList(quads);
}

void MainWindow::onSaveButtonClicked() {
    std::vector<std::vector<cv::Point>> quads;
    scanView->getQuads(quads);

    ScanProcessor processor;
    std::vector<cv::Mat> croppedImages = processor.cropImages(scanImage, quads, projectData.scanOrientation, croppedOrientation);

    // save images
    ImageSaver imageSaver;
    for (size_t i = 0; i < croppedImages.size(); ++i) {
        projectData.imagesCount++;
        QString file_name = QString::fromStdString(projectData.projectName) + "_" + QString::number(projectData.imagesCount) + ".jpg";
        QString file_path_name = QString::fromStdString(projectData.projectPath) + "/" + file_name;

        QDateTime *dt = new QDateTime(QDateTime::fromString(QString::fromStdString(projectData.imageDateTime), Qt::ISODate));

        // add 60 seconds
        QDateTime newDateTime = dt->addSecs(60);
        ui->dateTimeEdit->setDateTime(newDateTime);

        imageSaver.saveImage(croppedImages[i], file_path_name, QString::fromStdString(projectData.imageDateTime), projectData.imageLocation);
    }
    ui->projectCount->display(projectData.imagesCount);
    saveProjectData();
}

void MainWindow::onFindScannerButtonClicked() {
    try {
        if (!scanner) {
            scanner = ScannerInterface::createScanner();
        }

        if (!scanner) {
            QMessageBox::warning(this, "Error", "No suitable scanner backend found!");
            return;
        }

        // std::vector<std::wstring> scanners = scanner->getAvailableScanners();
        std::vector<std::wstring> scanners = scanner->getAvailableScanners();

        if (scanners.empty()) {
            QMessageBox::information(this, "Info", "No scanners found.");
            return;
        }

        // add to combo box
        QStringList scannerList;
        scannerList += QString("-");
        for (const auto &scanner : scanners) {
            scannerList += QString::fromStdWString(scanner);
        }

        ui->comboScanners->clear();
        ui->comboScanners->addItems(scannerList);
    } catch (const std::exception &e) {
        QMessageBox::warning(this, "Initialization Error", QString::fromStdString(e.what()));
    }
}

void MainWindow::onScannerSelectionChanged(QString scannerName) {
    if (scannerName == "-") {
        ui->btnScan->setEnabled(false);
        ui->groupProperties->setEnabled(false);
        return;
    }
    try {
        if (!scanner) {
            QMessageBox::warning(this, "Error", "No suitable scanner backend found!");
            return;
        }

        std::wstring scannerNameW = scannerName.toStdWString();

        projectData.scannerName = scannerName.toStdString();

        std::cout << "Selected scanner: " << scannerName.toStdString() << std::endl;

        scanner->setPreferredScanner(scannerNameW);

        ui->btnScan->setEnabled(true);
        ui->groupProperties->setEnabled(true);
    } catch (const std::exception &e) {
        QMessageBox::warning(this, "Error", QString::fromStdString(e.what()));
        ui->groupProperties->setEnabled(false);
        ui->comboScanners->setCurrentIndex(0);
        ui->btnScan->setEnabled(false);
    }
}

void MainWindow::onColorOptionChanged(int index) {
    if (index > 0) {
        try {
            scanner->setColorOption(index);
            projectData.scannerColor = index;
        } catch (const std::exception &e) {
            QMessageBox::warning(this, "Error", QString::fromStdString(e.what()));
            projectData.scannerColor = 0;
            ui->comboColor->setCurrentIndex(0);
        }
    }
}

void MainWindow::onDpiOptionChanged(int index) {
    try {
        switch (index) {
        case 1:
            scanner->setDpi(100);
            projectData.scannerDpi = 100;
            break;
        case 2:
            scanner->setDpi(200);
            projectData.scannerDpi = 200;
            break;
        case 3:
            scanner->setDpi(300);
            projectData.scannerDpi = 300;
            break;
        case 4:
            scanner->setDpi(600);
            projectData.scannerDpi = 600;
            break;

        default:
            break;
        }
    } catch (const std::exception &e) {
        QMessageBox::warning(this, "Error", QString::fromStdString(e.what()));
        ui->comboDPI->setCurrentIndex(0);
    }
}

void MainWindow::updateThumbnailsList(std::vector<std::vector<cv::Point>> quads) {
    // sort quads by the vector to their center

    sortQuadsByCenter(quads);

    if (croppedOrientation.size() != quads.size()) {
        // Check if all elements in croppedOrientation are the same
        int initializeValue = projectData.scanOrientation;
        if (!croppedOrientation.empty() &&
            std::all_of(croppedOrientation.begin(), croppedOrientation.end(),
                        [this](int val) { return val == croppedOrientation.front(); })) {
            initializeValue = croppedOrientation.front();
        }

        // Adjust size of croppedOrientation to match quads size
        while (croppedOrientation.size() < quads.size()) {
            croppedOrientation.push_back(initializeValue);
        }

        while (croppedOrientation.size() > quads.size()) {
            croppedOrientation.pop_back();
        }
    }

    qDebug() << "Updating thumbnails list with " << quads.size() << " quadrilaterals.";
    // Clear the existing listview
    croppedView->model()->removeRows(0, croppedView->model()->rowCount());

    // Use the ScanProcessor to crop the images
    ScanProcessor processor;
    croppedImages = processor.cropImages(scanImage, quads, projectData.scanOrientation, croppedOrientation);

    // Display the cropped images in the list
    for (size_t index = 0; index < croppedImages.size(); ++index) {
        const auto &cropped = croppedImages[index];

        // Convert cv::Mat to QImage
        QImage qImage = matToQImage(cropped);

        // Convert QImage to QPixmap
        QPixmap pixmap = QPixmap::fromImage(qImage);

        // Pass index to addImageItem if needed
        croppedView->addImageItem(pixmap, index);
    }
    croppedView->manualResize();
}

void MainWindow::saveProjectData() {
    Project::updateProject(projectPath, projectData);
}

void MainWindow::displayMatInGraphicsView(const cv::Mat &mat, ImageEditorView *graphicsView, QGraphicsScene *scene) {
    qDebug() << "Mat empty:" << mat.empty();
    qDebug() << "Mat type:" << mat.type();
    qDebug() << "Mat rows:" << mat.rows << ", cols:" << mat.cols;
    // Convert cv::Mat to QImage
    // Handle supported formats
    QImage qImage = matToQImage(mat);

    // Convert QImage to QPixmap
    QPixmap pixmap = QPixmap::fromImage(qImage);

    // clear scene
    scene->clear();

    scene->addPixmap(pixmap);

    // Set the scene to the graphics view
    graphicsView->setScene(scene);

    // Optional: Adjust the view to fit the image
    graphicsView->fitInView(scene->itemsBoundingRect(), Qt::KeepAspectRatio);
    graphicsView->positionButtons();
}

QImage MainWindow::matToQImage(const cv::Mat &mat) {
    // Check if the matrix is valid
    if (mat.empty()) {
        qDebug() << "Empty matrix provided to matToQImage.";
        return QImage();
    }

    switch (mat.type()) {
    case CV_8UC1: { // Grayscale
        return QImage(mat.data, mat.cols, mat.rows, static_cast<int>(mat.step), QImage::Format_Grayscale8).copy();
    }
    case CV_8UC3: { // BGR to RGB
        cv::Mat rgbMat;
        cv::cvtColor(mat, rgbMat, cv::COLOR_BGR2RGB);
        return QImage(rgbMat.data, rgbMat.cols, rgbMat.rows, static_cast<int>(rgbMat.step), QImage::Format_RGB888).copy();
    }
    case CV_8UC4: { // BGRA to RGBA
        return QImage(mat.data, mat.cols, mat.rows, static_cast<int>(mat.step), QImage::Format_RGBA8888).copy();
    }
    case CV_16UC1: { // 16-bit Grayscale
        // Normalize to 8-bit range [0, 255]
        cv::Mat mat8;
        mat.convertTo(mat8, CV_8UC1, 255.0 / 65535.0); // Scale 16-bit to 8-bit
        return QImage(mat8.data, mat8.cols, mat8.rows, static_cast<int>(mat8.step), QImage::Format_Grayscale8).copy();
    }
    case CV_16UC3: { // 16-bit BGR
        cv::Mat mat8;
        mat.convertTo(mat8, CV_8UC3, 255.0 / 65535.0); // Scale 16-bit to 8-bit
        cv::Mat rgbMat;
        cv::cvtColor(mat8, rgbMat, cv::COLOR_BGR2RGB);
        return QImage(rgbMat.data, rgbMat.cols, rgbMat.rows, static_cast<int>(rgbMat.step), QImage::Format_RGB888).copy();
    }
    default:
        qDebug() << "Unsupported matrix type for QImage conversion: " << mat.type();
        throw std::runtime_error("Unsupported cv::Mat type for QImage conversion.");
    }
}

cv::Point2f MainWindow::computeCentroid(const std::vector<cv::Point> &quad) {
    cv::Point2f centroid(0, 0);
    for (const auto &point : quad) {
        centroid.x += point.x;
        centroid.y += point.y;
    }
    centroid.x /= quad.size();
    centroid.y /= quad.size();
    return centroid;
}

// Main function to sort quads
void MainWindow::sortQuadsByCenter(std::vector<std::vector<cv::Point>> &quads, const cv::Point &reference) {
    sort(quads.begin(), quads.end(), [&reference](const std::vector<cv::Point> &a, const std::vector<cv::Point> &b) {
        cv::Point2f centroidA = computeCentroid(a);
        cv::Point2f centroidB = computeCentroid(b);

        float distanceA = sqrt(pow(centroidA.x - reference.x, 2) + pow(centroidA.y - reference.y, 2));
        float distanceB = sqrt(pow(centroidB.x - reference.x, 2) + pow(centroidB.y - reference.y, 2));

        return distanceA < distanceB; // Sort in ascending order
    });
}