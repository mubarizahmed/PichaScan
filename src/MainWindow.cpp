#include "MainWindow.h"
#include "ui_MainWindow.h"

#include "CroppedView.h"
#include "ImageEditorView.h"
#include "QuadrilateralItem.h"
#include "ScanProcessor.h"
#include "ScannerInterface.h"

#include <QDebug>
#include <QFileDialog>
#include <QGraphicsRectItem>
#include <QListWidget>
#include <QMessageBox>
#include <exiv2/exiv2.hpp>
#include "ImageSaver.h"

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), ui(new Ui::MainWindow) {

    scanner = nullptr;
    scanOrientation = 0;

    ui->setupUi(this);

    // Replace the autogenerated QGraphicsView with your custom class
    scanScene = new QGraphicsScene(this);
    // set white bg

    scanView = new ImageEditorView(this);
    scanView->setBackgroundBrush(Qt::white);
    scanView->setScene(scanScene);
    scanView->positionButtons();

    // Set the geometry and properties of the new scanView
    scanView->setGeometry(ui->scanView->geometry());
    scanView->setObjectName(ui->scanView->objectName());
    scanView->setSizePolicy(ui->scanView->sizePolicy());

    // Add scanView to the layout or as needed
    auto parentLayout = ui->scanView->parentWidget()->layout();
    if (parentLayout) {
        parentLayout->replaceWidget(ui->scanView, scanView);
    }

    // Delete the old QGraphicsView instance
    delete ui->scanView;
    ui->scanView = scanView;

    // Suppose you have a QPushButton named scanButton in your .ui
    connect(ui->btnScan, &QPushButton::clicked,
            this, &MainWindow::onScanButtonClicked);
    connect(ui->btnSave, &QPushButton::clicked, this, &MainWindow::onSaveButtonClicked);

    connect(ui->btnFindScanners, &QPushButton::clicked, this, &MainWindow::onFindScannerButtonClicked);

    connect(ui->comboScanners, SIGNAL(currentTextChanged(QString)), this, SLOT(onScannerSelectionChanged(QString)));

    connect(scanView, &ImageEditorView::quadrilateralsChanged, this, &MainWindow::updateThumbnailsList);
    connect(scanView, &ImageEditorView::scanRotated, [this](int angle) {
        int oldScanOrientation = scanOrientation;
        scanOrientation += angle;
        scanOrientation = (scanOrientation + 360) % 360;

        // Rotate the croppedImages
        if (std::all_of(croppedOrientation.begin(), croppedOrientation.end(),
                        [oldScanOrientation](int val) {
                            return val == -1 || val == oldScanOrientation;
                        })) {
            // Adjust elements if all are -1 or match the required condition
            for (auto &cropped : croppedOrientation) {
                cropped = scanOrientation;
            }
        }

        scanView->updateQuads();
    });

    onFindScannerButtonClicked();

    croppedView = new CroppedView(this);
    // croppedView->setGeometry(ui->listThumbnails->geometry());
    croppedView->setObjectName(ui->listThumbnails->objectName());
    croppedView->setSizePolicy(ui->listThumbnails->sizePolicy());

    // Add croppedView to the layout or as needed
    auto croppedParentLayout = ui->listThumbnails->parentWidget()->layout();
    if (croppedParentLayout) {
        croppedParentLayout->replaceWidget(ui->listThumbnails, croppedView);
    }

    connect(croppedView, &CroppedView::viewItemRotated, [this](int index, int angle) {
        int oldOrientation = croppedOrientation[index];
        croppedOrientation[index] += angle;
        croppedOrientation[index] = (croppedOrientation[index] + 360) % 360;

        // Rotate the cropped image
        if (oldOrientation == -1) {
            croppedOrientation[index] = angle;
        }

        scanView->updateQuads();
    });

    // Delete the old QListView instance
    delete ui->listThumbnails;
    ui->listThumbnails = croppedView;

    show();
    scanView->positionButtons();
}

MainWindow::~MainWindow() {
    delete ui;
}

void MainWindow::onScanButtonClicked() {

    if (!scanner) {
        QMessageBox::warning(this, "Error", "No suitable scanner backend found!");
        return;
    }

    // Perform the scan (returns a large image that might contain multiple photos)
    cv::Mat scannedImage = scanner->scanImage();
    if (scannedImage.empty()) {
        QMessageBox::warning(this, "Error", "Failed to scan or no image returned.");
        return;
    }

    scanImage = scannedImage;

    // Use the ScanProcessor to detect & crop
    ScanProcessor processor;
    ScanResult scanResult = processor.detectAndCropPhotos(scannedImage);

    // Display the scanned image in the graphics view
    MainWindow::displayMatInGraphicsView(scanResult.annotated, scanView, scanScene);

    // Add rectangles to the scanScene
    std::vector<std::vector<cv::Point>> quads;
    for (const auto &region : scanResult.regions) {
        scanView->addQuadrilateral(region.corners);
        quads.push_back(region.corners);
    }

    // Update the list of thumbnails
    updateThumbnailsList(quads);
}

void MainWindow::onSaveButtonClicked() {
    std::vector<std::vector<cv::Point>> quads;
    scanView->getQuads(quads);

    ScanProcessor processor;
    std::vector<cv::Mat> croppedImages = processor.cropImages(scanImage, quads, scanOrientation, croppedOrientation);

    // create file_path
    QString file_path = QDir::homePath() + "/Pictures/PichaScan/";
    QString project_name = "Test";

    // create directory
    QDir dir(file_path + project_name);
    if (!dir.exists()) {
        dir.mkpath(".");
    }

    // save images
    ImageSaver imageSaver;
    for (size_t i = 0; i < croppedImages.size(); ++i) {
        QString file_name = project_name + "_" + QString::number(i) + ".jpg";
        QString file_path_name = file_path + project_name + "/" + file_name;
        imageSaver.saveImage(croppedImages[i], file_path_name);
    }

}

void MainWindow::onFindScannerButtonClicked() {
    if (!scanner) {
        scanner = ScannerInterface::createScanner();
    }

    if (!scanner) {
        QMessageBox::warning(this, "Error", "No suitable scanner backend found!");
        return;
    }

    // std::vector<std::wstring> scanners = scanner->getAvailableScanners();
    std::vector<std::wstring> scanners = scanner->getAvailableScanners();

    if (scanners.empty()) {
        QMessageBox::information(this, "Info", "No scanners found.");
        return;
    }

    // add to combo box
    QStringList scannerList;
    for (const auto &scanner : scanners) {
        scannerList += QString::fromStdWString(scanner);
    }

    ui->comboScanners->addItems(scannerList);
}

void MainWindow::onScannerSelectionChanged(QString scannerName) {
    if (!scanner) {
        QMessageBox::warning(this, "Error", "No suitable scanner backend found!");
        return;
    }

    std::wstring scannerNameW = scannerName.toStdWString();

    std::cout << "Selected scanner: " << scannerName.toStdString() << std::endl;

    scanner->setPreferredScanner(scannerNameW);
}

void MainWindow::updateThumbnailsList(std::vector<std::vector<cv::Point>> quads) {
    // sort quads by the vector to their center

    sortQuadsByCenter(quads);

    if (croppedOrientation.size() != quads.size()) {
        // Check if all elements in croppedOrientation are the same
        int initializeValue = -1;
        if (!croppedOrientation.empty() &&
            std::all_of(croppedOrientation.begin(), croppedOrientation.end(),
                        [this](int val) { return val == croppedOrientation.front(); })) {
            initializeValue = croppedOrientation.front();
        }

        // Adjust size of croppedOrientation to match quads size
        while (croppedOrientation.size() < quads.size()) {
            croppedOrientation.push_back(initializeValue);
        }

        while (croppedOrientation.size() > quads.size()) {
            croppedOrientation.pop_back();
        }
    }

    qDebug() << "Updating thumbnails list with " << quads.size() << " quadrilaterals.";
    // Clear the existing listview
    croppedView->model()->removeRows(0, croppedView->model()->rowCount());

    // Use the ScanProcessor to crop the images
    ScanProcessor processor;
    croppedImages = processor.cropImages(scanImage, quads, scanOrientation, croppedOrientation);

    // Display the cropped images in the list
    for (size_t index = 0; index < croppedImages.size(); ++index) {
        const auto &cropped = croppedImages[index];

        // Convert cv::Mat to QImage
        QImage qImage = matToQImage(cropped);

        // Convert QImage to QPixmap
        QPixmap pixmap = QPixmap::fromImage(qImage);

        // Pass index to addImageItem if needed
        croppedView->addImageItem(pixmap, index);
    }
    croppedView->manualResize();
}

void MainWindow::displayMatInGraphicsView(const cv::Mat &mat, ImageEditorView *graphicsView, QGraphicsScene *scene) {
    qDebug() << "Mat empty:" << mat.empty();
    qDebug() << "Mat type:" << mat.type();
    qDebug() << "Mat rows:" << mat.rows << ", cols:" << mat.cols;
    // Convert cv::Mat to QImage
    // Handle supported formats
    QImage qImage = matToQImage(mat);

    // Convert QImage to QPixmap
    QPixmap pixmap = QPixmap::fromImage(qImage);

    // clear scene
    scene->clear();

    scene->addPixmap(pixmap);

    // Set the scene to the graphics view
    graphicsView->setScene(scene);

    // Optional: Adjust the view to fit the image
    graphicsView->fitInView(scene->itemsBoundingRect(), Qt::KeepAspectRatio);
    graphicsView->positionButtons();
}

QImage MainWindow::matToQImage(const cv::Mat &mat) {
    // Check if the matrix is valid
    if (mat.empty()) {
        qDebug() << "Empty matrix provided to matToQImage.";
        return QImage();
    }

    switch (mat.type()) {
    case CV_8UC1: { // Grayscale
        return QImage(mat.data, mat.cols, mat.rows, static_cast<int>(mat.step), QImage::Format_Grayscale8).copy();
    }
    case CV_8UC3: { // BGR to RGB
        cv::Mat rgbMat;
        cv::cvtColor(mat, rgbMat, cv::COLOR_BGR2RGB);
        return QImage(rgbMat.data, rgbMat.cols, rgbMat.rows, static_cast<int>(rgbMat.step), QImage::Format_RGB888).copy();
    }
    case CV_8UC4: { // BGRA to RGBA
        return QImage(mat.data, mat.cols, mat.rows, static_cast<int>(mat.step), QImage::Format_RGBA8888).copy();
    }
    case CV_16UC1: { // 16-bit Grayscale
        // Normalize to 8-bit range [0, 255]
        cv::Mat mat8;
        mat.convertTo(mat8, CV_8UC1, 255.0 / 65535.0); // Scale 16-bit to 8-bit
        return QImage(mat8.data, mat8.cols, mat8.rows, static_cast<int>(mat8.step), QImage::Format_Grayscale8).copy();
    }
    case CV_16UC3: { // 16-bit BGR
        cv::Mat mat8;
        mat.convertTo(mat8, CV_8UC3, 255.0 / 65535.0); // Scale 16-bit to 8-bit
        cv::Mat rgbMat;
        cv::cvtColor(mat8, rgbMat, cv::COLOR_BGR2RGB);
        return QImage(rgbMat.data, rgbMat.cols, rgbMat.rows, static_cast<int>(rgbMat.step), QImage::Format_RGB888).copy();
    }
    default:
        qDebug() << "Unsupported matrix type for QImage conversion: " << mat.type();
        throw std::runtime_error("Unsupported cv::Mat type for QImage conversion.");
    }
}

cv::Point2f MainWindow::computeCentroid(const std::vector<cv::Point> &quad) {
    cv::Point2f centroid(0, 0);
    for (const auto &point : quad) {
        centroid.x += point.x;
        centroid.y += point.y;
    }
    centroid.x /= quad.size();
    centroid.y /= quad.size();
    return centroid;
}

// Main function to sort quads
void MainWindow::sortQuadsByCenter(std::vector<std::vector<cv::Point>> &quads, const cv::Point &reference) {
    sort(quads.begin(), quads.end(), [&reference](const std::vector<cv::Point> &a, const std::vector<cv::Point> &b) {
        cv::Point2f centroidA = computeCentroid(a);
        cv::Point2f centroidB = computeCentroid(b);

        float distanceA = sqrt(pow(centroidA.x - reference.x, 2) + pow(centroidA.y - reference.y, 2));
        float distanceB = sqrt(pow(centroidB.x - reference.x, 2) + pow(centroidB.y - reference.y, 2));

        return distanceA < distanceB; // Sort in ascending order
    });
}